<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="title_Overall" xml:space="preserve">
    <value>SharpTiles</value>
  </data>
  <data name="title_Sub" xml:space="preserve">
    <value>R.Z. Slijp, 2008</value>
  </data>
  <data name="source_Reference" xml:space="preserve">
    <value>The contents of this reference guide is based on the 'JSTL Quick Reference' by Bill Siggelkow(2003)</value>
  </data>
  <data name="copyright_Notice" xml:space="preserve">
    <value>This document is not copyright protected. However the 'JSTL Quick Reference', which forms the base of this document, is copyrighted by Bill Siggelkow.</value>
  </data>
  <data name="title_ExpressionLanguage" xml:space="preserve">
    <value>Expression language</value>
  </data>
  <data name="title_Functions" xml:space="preserve">
    <value>Functions</value>
  </data>
  <data name="title_Tags" xml:space="preserve">
    <value>Tags</value>
  </data>
  <data name="required_False" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="required_True" xml:space="preserve">
    <value>Yes</value>
  </data>
  <data name="title_ExpressionLanguage_AttributeValues" xml:space="preserve">
    <value>In Attribute Values</value>
  </data>
  <data name="description_ExpressionLanguage_AttributeValues" xml:space="preserve">
    <value>&lt;ul&gt;
	&lt;li&gt;&lt;a:tag value="${{expr}}"/&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a:tag value="me${{expr}} ${{expr}}"/&gt;&lt;/li&gt;
  &lt;/ul&gt;</value>
  </data>
  <data name="title_ExpressionLanguage_BeanPropertyAccess" xml:space="preserve">
    <value>Bean Property Acces</value>
  </data>
  <data name="description_ExpressionLanguage_BeanPropertyAccess" xml:space="preserve">
    <value>bean.*name*</value>
  </data>
  <data name="title_ExpressionLanguage_IndexedPropertyAccess" xml:space="preserve">
    <value>Indexed Property Access</value>
  </data>
  <data name="description_ExpressionLanguage_IndexedPropertyAccess" xml:space="preserve">
    <value>bean.property.*index*</value>
  </data>
  <data name="title_ExpressionLanguage_MapPropertyAccess" xml:space="preserve">
    <value>Map Property Access</value>
  </data>
  <data name="description_ExpressionLanguage_MapPropertyAccess" xml:space="preserve">
    <value>bean.property.*key*</value>
  </data>
  <data name="description_BooleanTernaryExpressionParser" xml:space="preserve">
    <value>*&lt;boolean expression&gt;*?*&lt;expression evalulated when true&gt;*:*&lt;expression evalulated when false&gt;*</value>
  </data>
  <data name="description_MathFunctionParser" xml:space="preserve">
    <value>*math function*(*arg1*,*arg2*,...)</value>
  </data>
  <data name="description_PropertyOrConstantParser" xml:space="preserve">
    <value></value>
  </data>
  <data name="description_RegExReplaceFunction" xml:space="preserve">
    <value>Replaces in source, every match of the regex pattern with
the newValue. An empty string is returned when either inputString or
pattern are empty. If newVlaue is empty, all matched of the
pattern are removed.</value>
  </data>
  <data name="description_NowFunction" xml:space="preserve">
    <value>Returns the current time as DateTime object</value>
  </data>
  <data name="expression_MathExpression" xml:space="preserve">
    <value>Supported math expressions</value>
  </data>
  <data name="tag_Header_Attribute" xml:space="preserve">
    <value>Attribute</value>
  </data>
  <data name="tag_Header_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="tag_Header_Required" xml:space="preserve">
    <value>Required</value>
  </data>
  <data name="description_Core_Out_Value" xml:space="preserve">
    <value>Data to output</value>
  </data>
  <data name="description_Core_Out_Default" xml:space="preserve">
    <value>Fallback data to output if value is empty</value>
  </data>
  <data name="description_Core_Out_EscapeXml" xml:space="preserve">
    <value>*true* to escape special characters</value>
  </data>
  <data name="description_Core_Set_Value" xml:space="preserve">
    <value>Data to save No Body</value>
  </data>
  <data name="description_Core_Set_Property" xml:space="preserve">
    <value>Property of target to modify</value>
  </data>
  <data name="description_BaseCoreTagWithVariable_Var" xml:space="preserve">
    <value>Name of variable to store data. An existing variable will be changed. If the property is the property of an object(in any scope). The value of the property will be changed.</value>
  </data>
  <data name="description_BaseCoreTagWithVariable_Scope" xml:space="preserve">
    <value>Scope of variable</value>
  </data>
  <data name="description_BaseCoreTagWithOptionalVariable_Var" xml:space="preserve">
    <value>Name of variable to store data. An existing variable will be changed. If the property is the property of an object(in any scope). The value of the property will be changed.</value>
  </data>
  <data name="description_BaseUrlTagWithVariable_Scope" xml:space="preserve">
    <value>Scope of variable</value>
  </data>
  <data name="description_BaseUrlTagWithVariable_Var" xml:space="preserve">
    <value>Name of variable to store data. An existing variable will be changed. If the property is the property of an object(in any scope). The value of the property will be changed.</value>
  </data>
  <data name="description_BaseCoreTagWithOptionalVariable_Scope" xml:space="preserve">
    <value>Scope of variable</value>
  </data>
  <data name="description_Core_Remove_Var" xml:space="preserve">
    <value>Name of variable or property to delete. Deleting of properties is done by setting the value of properties to null.</value>
  </data>
  <data name="description_Core_Remove_Scope" xml:space="preserve">
    <value>Scope of variable.</value>
  </data>
  <data name="description_Core_Catch_Var" xml:space="preserve">
    <value>Name of variable to store data. An existing variable will be changed. If the property is the property of an object(in any scope). The value of the property will be changed.</value>
  </data>
  <data name="description_Core_Catch_Scope" xml:space="preserve">
    <value>Scope of variable.</value>
  </data>
  <data name="description_Core_If_Test" xml:space="preserve">
    <value>Condition to evaluate.</value>
  </data>
  <data name="description_Core_Choose_When_Test" xml:space="preserve">
    <value>Condition to evaluate.</value>
  </data>
  <data name="description_Core_ForEach_Items" xml:space="preserve">
    <value>Collection, iterator, map, or array to loop over.</value>
  </data>
  <data name="description_BaseIterationTag_Begin" xml:space="preserve">
    <value>Zero-based index of first item to process, inclusive.</value>
  </data>
  <data name="description_BaseIterationTag_End" xml:space="preserve">
    <value>Zero-based index of last item to process, inclusive.</value>
  </data>
  <data name="description_BaseIterationTag_Step" xml:space="preserve">
    <value>Process every stepth element (e.g 2 = every second element).</value>
  </data>
  <data name="description_BaseIterationTag_Var" xml:space="preserve">
    <value>Name of variable to hold the current item. This variable has only nested visibility.</value>
  </data>
  <data name="description_BaseIterationTag_VarStatus" xml:space="preserve">
    <value>Name of variable to hold the loop status with the following properties:
		   
* index - position of the current item
* count - number of times through the loop (starting with 1)
* first - boolean indicator if this is the first iteration
* boolean indicator if this is the last iteration
	</value>
  </data>
  <data name="description_Core_ForTokens_Items" xml:space="preserve">
    <value>String of tokens to loop over.</value>
  </data>
  <data name="description_Core_ForTokens_Delims" xml:space="preserve">
    <value>Set of characters that separate the tokens (e.g. delims=",;" will tokenize a string separated by commas or semi-colons).</value>
  </data>
  <data name="description_Core_Url_Value" xml:space="preserve">
    <value>URL to be processed.</value>
  </data>
  <data name="description_Core_Import_Url" xml:space="preserve">
    <value>URL of the resource to import.</value>
  </data>
  <data name="description_Core_Redirect_Url" xml:space="preserve">
    <value>URL of the resource to redirect to.</value>
  </data>
  <data name="description_Core_Url_Param_Name" xml:space="preserve">
    <value>Name of the query string parameter.</value>
  </data>
  <data name="description_Core_Url_Param_Value" xml:space="preserve">
    <value>Value of the parameter. If not specified, value is taken from the tag body.</value>
  </data>
  <data name="description_Core_Import_Param_Name" xml:space="preserve">
    <value>Name of the query string parameter.</value>
  </data>
  <data name="description_Core_Import_Param_Value" xml:space="preserve">
    <value>Value of the parameter. If not specified, value is taken from the tag body.</value>
  </data>
  <data name="description_Core_Redirect_Param_Name" xml:space="preserve">
    <value>Name of the query string parameter.</value>
  </data>
  <data name="description_Core_Redirect_Param_Value" xml:space="preserve">
    <value>Value of the parameter. If not specified, value is taken from the tag body.</value>
  </data>
  <data name="description_Format_SetLocale_Value" xml:space="preserve">
    <value>String representation of a locale (e.g. en-US) or an actual java.util.Locale object.</value>
  </data>
  <data name="description_Format_SetLocale_Scope" xml:space="preserve">
    <value>Scope to set the default locale for.</value>
  </data>
  <data name="description_Format_Bundle_BaseName" xml:space="preserve">
    <value>Fully-qualified name of the base bundle without a file type (such as ".resx").</value>
  </data>
  <data name="description_Format_Bundle_Extension" xml:space="preserve">
    <value>Optional dictionary to extend the loaded resource bundle.</value>
  </data>
  <data name="description_Format_Bundle_Prefix" xml:space="preserve">
    <value>String prefix to be prepended to the value of the message key. Note that the prefix must include all characters – a separator character (e.g. ".") is not assumed.</value>
  </data>
  <data name="description_Format_SetBundle_BaseName" xml:space="preserve">
    <value>Fully-qualified name of the base bundle without a file type (such as ".properties").</value>
  </data>
  <data name="description_Format_Message_Key" xml:space="preserve">
    <value>Message key to be looked up.</value>
  </data>
  <data name="description_Format_Message_Bundle" xml:space="preserve">
    <value>Localization context (set by prio configuration, &lt;fmt:bundle&gt;, or &lt;fmt:setBundle&gt;, which specifies the resource bundle the message key is to be looked up in.</value>
  </data>
  <data name="description_Format_Message_Param_Value" xml:space="preserve">
    <value>Value used for parametric message format substitution.</value>
  </data>
  <data name="description_Format_RequestEncoding_Value" xml:space="preserve">
    <value>Character encoding (e.g. "UTF-8") to use.</value>
  </data>
  <data name="description_Format_FormatNumber_Value" xml:space="preserve">
    <value>Numeric value to format.</value>
  </data>
  <data name="description_Format_FormatNumber_Type" xml:space="preserve">
    <value>Specifies the type of value. Valid values are:
	</value>
  </data>
  <data name="description_Format_FormatNumber_Pattern" xml:space="preserve">
    <value>Custom formatting pattern (overrides other formatting options including type - see System.Globalization.NumberFormatInfo)</value>
  </data>
  <data name="description_Format_FormatNumber_CurrencyCode" xml:space="preserve">
    <value>Currency code (ISO 4217) used for formatting currencies. Such as "USD" (US dollars) or "EUR" (euro).</value>
  </data>
  <data name="description_Format_FormatNumber_CurrencySymbol" xml:space="preserve">
    <value>Currency symbol used when formatting currencies. Such as "$" for US dollars, or "F" for Francs.</value>
  </data>
  <data name="description_Format_FormatNumber_GroupingUsed" xml:space="preserve">
    <value>Specifies if grouping separators will be used (for example - formatting "23890" as "23,890").</value>
  </data>
  <data name="description_Format_FormatNumber_MinFractionDigits" xml:space="preserve">
    <value>Maximum number of digits to print in the fractional part of the number.</value>
  </data>
  <data name="description_Format_FormatNumber_MaxFractionDigits" xml:space="preserve">
    <value>Minimum number of digits to print in the fractional part of the number.</value>
  </data>
  <data name="description_Format_FormatNumber_MinIntegerDigits" xml:space="preserve">
    <value>Maximum number of digits to print in the integer part of the number.</value>
  </data>
  <data name="description_Format_FormatNumber_MaxIntegerDigits" xml:space="preserve">
    <value>Minimum number of digits to print in the integer part of the number.</value>
  </data>
  <data name="description_Format_ParseNumber_Value" xml:space="preserve">
    <value>Value to parse.</value>
  </data>
  <data name="description_Format_ParseNumber_Type" xml:space="preserve">
    <value>Specifies the type of value. Valid values are:
	</value>
  </data>
  <data name="description_Format_ParseNumber_Styles" xml:space="preserve">
    <value>Specifies the number style of value as "," seperated list. Valid values are String representation of System.Globalization.NumberStyles:		
	</value>
  </data>
  <data name="description_Format_ParseNumber_ParseLocale" xml:space="preserve">
    <value>String representation of a locale (e.g. en_US) or an actual System.Globalization.CultureInfo object used for parsing.</value>
  </data>
  <data name="description_Format_ParseNumber_IntegerOnly" xml:space="preserve">
    <value>Specifies if only the integer portion of the value should be parsed.</value>
  </data>
  <data name="description_Format_FormatDate_Value" xml:space="preserve">
    <value>Date value to format. Value must be a System.Date object or String representation.</value>
  </data>
  <data name="description_BaseDateTag_Type" xml:space="preserve">
    <value>Specifies the type of value. Valid values are:</value>
  </data>
  <data name="description_BaseDateTag_DateStyle" xml:space="preserve">
    <value>Predefined formatting style for a date (ignored if type="time") - see System.Globalization.DateTimeFormatInfo</value>
  </data>
  <data name="description_BaseDateTag_TimeStyle" xml:space="preserve">
    <value>Predefined formatting style for a time (ignored if type="date") - see System.Globalization.DateTimeFormatInfo. Valid values are:</value>
  </data>
  <data name="description_BaseDateTag_Pattern" xml:space="preserve">
    <value>Custom formatting style (overrides type, dateStyle, and timeStyle) - see System.Globalization.DateTimeFormatInfo.</value>
  </data>
  <data name="description_Format_ParseDate_Value" xml:space="preserve">
    <value>Date/time string to parse.</value>
  </data>
  <data name="description_Format_ParseDate_ParseLocale" xml:space="preserve">
    <value>String representation of a locale (e.g. en_US) or an actual System.Globalization.CultureInfo object used for parsing.</value>
  </data>
  <data name="description_Format_ParseDate_Exact" xml:space="preserve">
    <value>Forces the date parser to do an exact parse.</value>
  </data>
  <data name="description_Xml_Parse_Doc" xml:space="preserve">
    <value>Text of the document to a parse as a String or Reader</value>
  </data>
  <data name="description_Xml_Out_Source" xml:space="preserve">
    <value>Var containing DOM model where the XPath expression is run over.</value>
  </data>
  <data name="description_Xml_Out_Select" xml:space="preserve">
    <value>XPath expression.</value>
  </data>
  <data name="description_Xml_Out_EscapeXml" xml:space="preserve">
    <value>true to escape special characters</value>
  </data>
  <data name="description_Xml_Set_Source" xml:space="preserve">
    <value>Var containing DOM model where the XPath expression is run over.</value>
  </data>
  <data name="description_Xml_Set_Select" xml:space="preserve">
    <value>XPath expression.</value>
  </data>
  <data name="description_Xml_If_Source" xml:space="preserve">
    <value>Var containing DOM model where the XPath expression is run over.</value>
  </data>
  <data name="description_Xml_If_Select" xml:space="preserve">
    <value>XPath expression.</value>
  </data>
  <data name="description_Xml_Choose_When_Source" xml:space="preserve">
    <value>Var containing DOM model where the XPath expression is run over.</value>
  </data>
  <data name="description_Xml_Choose_When_Select" xml:space="preserve">
    <value>XPath expression.</value>
  </data>
  <data name="description_Xml_ForEach_Source" xml:space="preserve">
    <value>Var containing DOM model where the XPath expression is run over.</value>
  </data>
  <data name="description_Xml_ForEach_Select" xml:space="preserve">
    <value>XPath expression.</value>
  </data>
  <data name="description_Xml_Transform_Doc" xml:space="preserve">
    <value>Source XML document for the transformation. Value can be a String, Stream, TextReader, XmlReader, System.Xml.XPath.XPathDocument or any value exported &lt;x:parse&gt; or &lt;x:set&gt;.</value>
  </data>
  <data name="description_Xml_Transform_CacheVar" xml:space="preserve">
    <value>Var to save a cached instance of the parsed xsl template in.</value>
  </data>
  <data name="description_Xml_Transform_CacheScope" xml:space="preserve">
    <value>Scope of the cached instance.</value>
  </data>
  <data name="description_Xml_Transform_Xslt" xml:space="preserve">
    <value>XSLT stylesheet to use. The value must be String, Stream, TextReader, XmlReader, System.Xml.XPath.XPathDocument or any value exported &lt;x:parse&gt; or &lt;x:set&gt;.</value>
  </data>
  <data name="description_Xml_Transform_Param_Name" xml:space="preserve">
    <value>Name of the parameter as a String. This name must match the name in the corresponding &lt;xsl:param&gt; XSLT tag.</value>
  </data>
  <data name="description_Xml_Transform_Param_Value" xml:space="preserve">
    <value>Value of the parameter. If not specified, value is taken from the tag body.</value>
  </data>
  <data name="description_Xml_Transform_Param_NameSpaceUri" xml:space="preserve">
    <value>Namespace uri used in the &lt;xsl:param&gt;</value>
  </data>
  <data name="description_Sharp_Console" xml:space="preserve">
    <value>Prints a message on the console</value>
  </data>
  <data name="description_Sharp_Console_Value" xml:space="preserve">
    <value>value to output</value>
  </data>
  <data name="description_Sharp_Marker_Id" xml:space="preserve">
    <value>Marker Id which will return in the output</value>
  </data>
  <data name="description_Sharp_Include_File" xml:space="preserve">
    <value>Includes the template into current template</value>
  </data>
  <data name="description_Core_Title" xml:space="preserve">
    <value>Core *Tag Library*</value>
  </data>
  <data name="description_Format_Title" xml:space="preserve">
    <value>Formatting  *Tag Library*</value>
  </data>
  <data name="description_Xml_Title" xml:space="preserve">
    <value>XML *Tag Library*</value>
  </data>
  <data name="description_Sharp_Title" xml:space="preserve">
    <value>Sharp *Tag Library*</value>
  </data>
  <data name="description_Core" xml:space="preserve">
    <value>The core tag lib provides basic functionality for page flow, rendering and handling variables.</value>
  </data>
  <data name="description_Core_GeneralPurpose" xml:space="preserve">
    <value>&lt;h3&gt;General-Purpose Actions&lt;/h3&gt;&lt;br/&gt;Actions for rendering data, creating and modifying scoped variables, and catching exceptions.</value>
  </data>
  <data name="description_Core_Conditional" xml:space="preserve">
    <value>&lt;h3&gt;Conditional Actions&lt;/h3&gt;&lt;br/&gt;Actions for processing markup based on logical conditions.</value>
  </data>
  <data name="description_Core_Iterator" xml:space="preserve">
    <value>&lt;h3&gt;Iterator Actions&lt;/h3&gt;&lt;br/&gt;Actions that loop over collections, for a fixed number of times, or over a set of string tokens. These actions share a lot of the same attributes for iterating over a subset of elements.</value>
  </data>
  <data name="description_Core_URLRelated" xml:space="preserve">
    <value>&lt;h3&gt;URL Related Actions&lt;/h3&gt;&lt;br/&gt;Actions for importing content from URLs, building URLs, and redirecting.</value>
  </data>
  <data name="description_Format" xml:space="preserve">
    <value>The formatting tag lib handles the translations, character setsand the parsing and formatting of numbers and dates</value>
  </data>
  <data name="description_Format_Internationalization" xml:space="preserve">
    <value>&lt;h3&gt;Internationalization (I18N) Actions&lt;/h3&gt;&lt;br/&gt;Actions that establish localization (l10n) contexts, specify resource bundles, and format messages. </value>
  </data>
  <data name="description_Format_Formatting" xml:space="preserve">
    <value>&lt;h3&gt;Internationalization (I18N) Actions&lt;/h3&gt;&lt;br/&gt;Actions that format and parse numbers, currencies, percentages, dates and times.</value>
  </data>
  <data name="description_Xml" xml:space="preserve">
    <value>The XML tag library supports parsing of XML documents, selection of XML fragments, conditional and iterative processing based on XML content, and
			XSLT transformations. A common pattern for using the XML tags is as follows:

1. Use *&lt;x:parse&gt;* to parse XML into a scoped variable. The XML can come from the body literally, from the body via *&lt;c:import&gt;*, or from the 
	value attribute which may refer to any XML source. &lt;x:parse var="varName" ...&gt;

2. Use the scoped variable from  *&lt;x:parse&gt;* to specify the XML document to use in XPath expressions. *&lt;x:out source="${{varName}}" select="XPathexpression"/&gt;*
	    The following example demonstrates the above techniques.				
	</value>
  </data>
  <data name="tags_Nesting" xml:space="preserve">
    <value>Inside the {0} tag. The following tags are defined:</value>
  </data>
  <data name="description_Xml_XMLActions" xml:space="preserve">
    <value>&lt;h3&gt;General-Purpose Actions&lt;/h3&gt;&lt;br/&gt;Actions for parsing XML, outputting to the page, and selecting XML fragments. The examples that follow
demonstrate use of the XML tags for processing Rich Site Summary (RSS) feeds. RSS has more or less the following format:</value>
  </data>
  <data name="description_Xml_Conditional" xml:space="preserve">
    <value>&lt;h3&gt;Conditional Actions&lt;/h3&gt;&lt;br/&gt;Actions that format and parse numbers, currencies, percentages, dates and times.</value>
  </data>
  <data name="description_Xml_Iterator" xml:space="preserve">
    <value>&lt;h3&gt;Iterator Actions&lt;/h3&gt;&lt;br/&gt;Actions that format and parse numbers, currencies, percentages, dates and times.</value>
  </data>
  <data name="description_Xml_Transformation" xml:space="preserve">
    <value>&lt;h3&gt;Transformation Actions&lt;/h3&gt;&lt;br/&gt;JSTL provides an *&lt;x:transform&gt;* tag for performing XSLT transformations. The *&lt;x:param&gt;* tag can be nested in the *&lt;x:transform&gt;* tag to set a parameter that is used in the stylesheet.</value>
  </data>
  <data name="description_Sharp" xml:space="preserve">
    <value>###Sharp Actions
Miscelanious actions.</value>
  </data>
  <data name="description_Core_Out" xml:space="preserve">
    <value>renders data to the page</value>
  </data>
  <data name="description_Core_Set" xml:space="preserve">
    <value>saves data to a scoped variable</value>
  </data>
  <data name="description_Core_Remove" xml:space="preserve">
    <value>deletes a scoped variable</value>
  </data>
  <data name="description_Core_Catch" xml:space="preserve">
    <value>traps all exceptions or errors from the enclosed body.</value>
  </data>
  <data name="description_Core_If" xml:space="preserve">
    <value>processes the body if test is true</value>
  </data>
  <data name="description_Core_Choose" xml:space="preserve">
    <value>multiple conditions - processes the body of the &lt;b&gt;first&lt;/b&gt; enclosed *when* tag where the test 
   condition is true. If none match then the body of the *otherwise* tag (if present) is processed.</value>
  </data>
  <data name="description_Core_Choose_When" xml:space="preserve">
    <value>processes the body if test is true and no
other previous *&lt;c:when&gt;* tags evaluated to true.</value>
  </data>
  <data name="description_Core_Choose_Otherwise" xml:space="preserve">
    <value>processes the body if no other previous *&lt;c:when&gt;* condition was matched. This tag accepts no attributes and, if present, must be the 
   last tag in the *&lt;c:choose&gt;* body.</value>
  </data>
  <data name="description_Core_ForEach" xml:space="preserve">
    <value>repeats the nested body content over a collection or for a fixed number of times.</value>
  </data>
  <data name="description_Core_ForTokens" xml:space="preserve">
    <value>repeats the nested body content for each token of a delimited string.</value>
  </data>
  <data name="description_Core_Import" xml:space="preserve">
    <value>imports the content of a URL-based resource. Action may include nested *&lt;c:param&gt;* tags to specify the query string (unless the varReader  attribute is specified).</value>
  </data>
  <data name="description_Core_Url" xml:space="preserve">
    <value>builds a URL with the proper rewriting rules applied (only relative URLs are rewritten). Action may include nested *&lt;c:param&gt;* tags to specify the query string.</value>
  </data>
  <data name="description_Core_Redirect" xml:space="preserve">
    <value>sends the client a response to redirect to the specified URL. This action will abort processing of the current page. Action may include nested *&lt;c:param&gt;* tags to specify the query string.</value>
  </data>
  <data name="description_Core_Url_Param" xml:space="preserve">
    <value>adds request parameters to a URL.</value>
  </data>
  <data name="description_Core_Import_Param" xml:space="preserve">
    <value>adds request parameters to a URL.</value>
  </data>
  <data name="description_Core_Redirect_Param" xml:space="preserve">
    <value>adds request parameters to a URL.</value>
  </data>
  <data name="description_Format_SetLocale" xml:space="preserve">
    <value>Sets the default locale for the specified scope. This will override the browserbased locale.</value>
  </data>
  <data name="description_Format_RequestEncoding" xml:space="preserve">
    <value>Instructs JSTL to use a specific character encoding (see &lt;a href="http://www.iana.org/assignments/character-sets"&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;) to decode request parameters. Omitting a value indicates to use automatic detection of the proper encoding.</value>
  </data>
  <data name="description_Format_Bundle" xml:space="preserve">
    <value>Sets the localization context, based on the specified resource bundle, to be used within the body content of this tag.</value>
  </data>
  <data name="description_Format_SetBundle" xml:space="preserve">
    <value>Creates and stores in a scoped variable, a localization context based on the specified resource bundle.</value>
  </data>
  <data name="description_Format_Message" xml:space="preserve">
    <value>Looks up a localized message in a resource bundle. This tag can contain nested *&lt;fmt:param&gt;* tags to specify message format substitution values. The resultant message is printed or stored in a scoped variable.</value>
  </data>
  <data name="description_Format_Message_Param" xml:space="preserve">
    <value>Supplies a parameter for message  format substitution in a containing *&lt;fmt:message&gt;* tag. Parameters are substituted in sequential order.</value>
  </data>
  <data name="description_Format_FormatNumber" xml:space="preserve">
    <value>Formats a number, currency, or percentage in a locale-sensitive manner. The formatted value is printed or stored in a scoped variable.</value>
  </data>
  <data name="description_Format_ParseNumber" xml:space="preserve">
    <value>Parses a String representing a number, currency, or percentage in a localesensitive manner. The parsed value is printed or stored in a scoped variable.</value>
  </data>
  <data name="description_Format_FormatDate" xml:space="preserve">
    <value>Formats a date and/or time in a locale-sensitive manner. The formatted value is printed or stored in a scoped variable.</value>
  </data>
  <data name="description_Format_ParseDate" xml:space="preserve">
    <value>Parses a string representing a date and/or time in a locale-sensitive manner. The parsed value is printed or stored in a scoped variable.</value>
  </data>
  <data name="description_Xml_Parse" xml:space="preserve">
    <value>Parses XML content, provided by the value attribute or the tags body, into a scoped variable(s). This variable can then be used for subsequent processing by other XML tags.</value>
  </data>
  <data name="description_Xml_Out" xml:space="preserve">
    <value>Prints the result of the XPath expression as a string.</value>
  </data>
  <data name="description_Xml_Set" xml:space="preserve">
    <value>Saves the result of the select XPath expression to a scoped variable. Returned value may be a node set (XML fragment), boolean, string, or number.</value>
  </data>
  <data name="description_Xml_If" xml:space="preserve">
    <value>Processes the body if select XPath evaluates to true (following the rules of the boolean() XPath function).</value>
  </data>
  <data name="description_Xml_Choose" xml:space="preserve">
    <value>Processes the body of the &lt;b&gt;first&lt;/b&gt; enclosed *&lt;x:when&gt;* tag where the select XPath expression evaluates to true. If none match then the body of the *&lt;x:otherwise&gt;* tag (if present)
is processed.</value>
  </data>
  <data name="description_Xml_Choose_When" xml:space="preserve">
    <value>Represents an alternative in an *&lt;x:choose&gt;* tag. Processes the body if the select expression evaluates to true and no other previous *&lt;x:when&gt;* tags in the *&lt;x:choose&gt;*
matched.</value>
  </data>
  <data name="description_Xml_Choose_Otherwise" xml:space="preserve">
    <value>Processes the body if no other previous *&lt;x:when&gt;* condition in the *&lt;x:choose&gt;* matched. This tag accepts no attributes and, if present, must be the last tag in
*&lt;x:choose&gt;* body.</value>
  </data>
  <data name="description_Xml_ForEach" xml:space="preserve">
    <value>Repeats the nested body content over a node set determined by an XPath expression, setting the context node to each element in the iteration.</value>
  </data>
  <data name="description_Xml_Transform" xml:space="preserve">
    <value>Conducts an XSLT transformation on source XML. The source XML is provided by the doc attribute or the body of the tag. The XSL stylesheet is specified by the  *xslt* attribute. While in most cases, the stylesheet will be set up by back-end code - it is possible to define the stylesheet inline and make it available with *&lt;c:set&gt;* as in the
following example:</value>
  </data>
  <data name="description_Xml_Transform_Param" xml:space="preserve">
    <value>Sets a transformation parameter that will be passed to stylesheet which declares parameters using the *&lt;xsl:param&gt;* tag. 
   The *&lt;x:param&gt;* tag can only be nested within an *&lt;x:transform&gt;* tag. Any *&lt;x:param&gt;*
   tags must come after the XML body content of the *&lt;x:transform&gt;* tag, if present.</value>
  </data>
  <data name="description_Sharp_Marker" xml:space="preserve">
    <value>Marks the nested body. The body is included inside a *&lt;div&gt;* element.</value>
  </data>
  <data name="description_Sharp_Include" xml:space="preserve">
    <value>Includes and evaluates a fragment.</value>
  </data>
  <data name="description_Core_Out_Example" xml:space="preserve">
    <value>&lt;h2&gt;Welcome, &lt;c:out value="${{user.name}}" default="Guest"/&gt;&lt;/h2&gt;</value>
  </data>
  <data name="description_Core_Set_Example" xml:space="preserve">
    <value>&lt;c:set var="dogAge" value="${{age div 7}}"/&gt; You are &lt;c:out value="${{dogAge}}"/&gt; in dog years.</value>
  </data>
  <data name="description_Core_Remove_Example" xml:space="preserve">
    <value>&lt;c:remove var="dogAge" scope="page"/&gt;</value>
  </data>
  <data name="description_Core_Catch_Example" xml:space="preserve">
    <value>&lt;c:catch var="err"&gt;
    &lt;c:import value="http://www.sharptiles.org"/&gt;
&lt;/c:catch&gt;
&lt;c:if test="${{not empty err}}"&gt;
    Could not connect to Sharptiles web site.
&lt;/c:if&gt;</value>
  </data>
  <data name="description_Core_If_Example" xml:space="preserve">
    <value>&lt;c:if test="${{user.age ge '40'}}"&gt; You are over the hill. &lt;/c:if&gt;</value>
  </data>
  <data name="description_Format_SetLocale_Example" xml:space="preserve">
    <value>&lt;fmt:setLocale scope="session" value="fr-CA"/&gt;</value>
  </data>
  <data name="description_Format_RequestEncoding_Example" xml:space="preserve">
    <value>&lt;fmt:requestEncoding key="UTF-7"/&gt;</value>
  </data>
  <data name="description_Format_Bundle_Example" xml:space="preserve">
    <value>&lt;fmt:bundle baseName="resources" prefix="label."&gt;
    &lt;fmt:message key="userId"/&gt;    
&lt;fmt:bundle&gt;
  </value>
  </data>
  <data name="description_Format_SetBundle_Example" xml:space="preserve">
    <value>&lt;fmt:setBundle baseName="ApplicationResources" var="tilesMessages" scope="Application"/&gt;</value>
  </data>
  <data name="description_Format_Message_Example" xml:space="preserve">
    <value>&lt;fmt:message key="title" bundle="${{tilesMessages}}"/&gt;</value>
  </data>
  <data name="description_Format_FormatNumber_Example" xml:space="preserve">
    <value>&lt;fmt:formatNumber type="Currency" value="3.977"&gt;</value>
  </data>
  <data name="description_Format_ParseNumber_Example" xml:space="preserve">
    <value>&lt;fmt:parseNumber var="num" type="Number" Styles="AllowDecimalPoint,AllowThousands" value="2,447"/&gt;
&lt;c:out value="${{num}}"/&gt;</value>
  </data>
  <data name="description_Format_FormatDate_Example" xml:space="preserve">
    <value>&lt;fmt:formatDate value="${{now}}" pattern="yy-MMM-dd&gt;"/&gt;</value>
  </data>
  <data name="description_Format_ParseDate_Example" xml:space="preserve">
    <value>&lt;fmt:parseDate var="bday" pattern="MM/dd/yy" value="05/10/63"/&gt;
&lt;fmt:formatDate value="${{bday}}" dateStyle="Long"/&gt;</value>
  </data>
  <data name="description_Core_Choose_Example" xml:space="preserve">
    <value>&lt;c:choose&gt;
    &lt;c:when test="${{a boolean expr}}"&gt;
        // do something
    &lt;/c:when&gt;
    &lt;c:when test="${{another boolean expr}}"&gt;
        // do something else
    &lt;/c:when&gt;
    &lt;c:otherwise&gt;
        // do this when nothing else is true
    &lt;/c:otherwise&gt;
&lt;/c:choose&gt;</value>
  </data>
  <data name="description_Xml_Parse_Example" xml:space="preserve">
    <value>&lt;c:import var="rss" url="http://news.google.com/?output=rss"/&gt;    
&lt;x:parse var="news" xml="${{rss}}"/&gt;</value>
  </data>
  <data name="description_Xml_Out_Example" xml:space="preserve">
    <value>&lt;x:out source="${{news}}" select="//channel/title"/&gt;</value>
  </data>
  <data name="description_Xml_Set_Example" xml:space="preserve">
    <value>&lt;x:set source="${{news}}" select="//channel/item"
var="newsItems"/&gt;</value>
  </data>
  <data name="description_Xml_If_Example" xml:space="preserve">
    <value>&lt;x:if source="${{news}}" select="item[contains(description,'Linux')]"&gt;    
    Linux is in the news today!    
&lt;/x:if&gt;</value>
  </data>
  <data name="description_Xml_Choose_Example" xml:space="preserve">
    <value>&lt;x:choose&gt;    
    &lt;x:when source="${{news}}" select="//item"&gt;    
        We've got news :)    
    &lt;/x:when&gt;    
    &lt;x:otherwise&gt;    
        No news today :(    
    &lt;/x:otherwise&gt;    
&lt;/x:choose&gt;</value>
  </data>
  <data name="description_Xml_ForEach_Example" xml:space="preserve"><value>&lt;x:forEach source="${{news}}" select="//item"&gt;
    &lt;a href='&lt;x:out select="link"/&gt;'&gt;
    &lt;x:out select="title"/&gt;&lt;/a&gt;
&lt;/x:forEach&gt;</value>
  </data>
  <data name="description_Xml_Transform_Example" xml:space="preserve">
    <value>&lt;c:set var="xsl"&gt;    
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
        &lt;xsl:template match="item"&gt;
            &lt;li&gt;
                &lt;xsl:value-of select="title"/&gt;
            &lt;/li&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="/"&gt;
        &lt;ol&gt;
            &lt;xsl:apply-templates select="//item"/&gt;
        &lt;/ol&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/c:set&gt;
&lt;x:transform doc="${{news}}" xslt="${{xsl}}"/&gt;  
   </value>
  </data>
  <data name="description_Xml_Transform_Param_Example" xml:space="preserve">
    <value>&lt;x:transform doc="${{news}}" xslt="${{searchXsl}}"/&gt;    
    &lt;x:param name="searchParam"&gt;Web Services&lt;/x:param&gt;
&lt;/x:transform&gt;</value>
  </data>
  <data name="description_Core_ForEach_Example" xml:space="preserve">
    <value>&lt;c:forEach items="${{user.languages}}" var="lang" varStatus="status"&gt;    
    &lt;c:if test="${{status.first}}"&gt;    
        You speak these languages:    
        &lt;ul&gt;    
    &lt;/c:if&gt;    
    &lt;li&gt;&lt;c:out value="${{lang}}"/&gt;&lt;/li&gt;
    &lt;c:if test="${{status.last}}"&gt;&lt;/ul&gt;&lt;/c:if&gt;    
&lt;/c:forEach&gt;</value>
  </data>
  <data name="description_Core_ForTokens_Example" xml:space="preserve">
    <value>&lt;c:set var="users"&gt;Fred,Joe,Mary&lt;c:set&gt;    
&lt;c:forTokens var="name" items="${{users}}" delims=","&gt;    
    &lt;c:out value="${{name}}"/&gt;    
&lt;/c:forTokens&gt;</value>
  </data>
  <data name="description_Core_Url_Example" xml:space="preserve">
    <value>&lt;c:url="editProfile.do" var="profileLnk"&gt;    
        &lt;c:param name="id" value="${{user.id}}"/&gt;    
&lt;/c:url&gt;    
&lt;a href='&lt;c:out value="${{profileLnk}}"/&gt;'&gt;    
        Edit Profile    
&lt;/a&gt;</value>
  </data>
  <data name="description_Core_Import_Example" xml:space="preserve">
    <value>&lt;c:import url="includes/header.aspx"&gt; 
    &lt;c:param name="title"&gt;Hello World&lt;/c:param&gt;    
&lt;/c:import&gt;</value>
  </data>
  <data name="description_Core_Redirect_Example" xml:space="preserve">
    <value>&lt;c:if test="${{empty user}}"&gt;    
    &lt;c:redirect url="login.aspx"/&gt;    
&lt;/c:if&gt;</value>
  </data>
  <data name="description_Xml_Example" xml:space="preserve">
    <value>
&lt;x:parse var="doc"&gt;    
    &lt;users&gt;    
        &lt;user id="997"&gt;    
            &lt;first-name&gt;George&lt;/first-name&gt;    
            &lt;last-name&gt;Burdell&lt;/last-name&gt;    
        &lt;/user&gt;    
    &lt;user id="998"&gt;    
            &lt;first-name&gt;Joseph&lt;/first-name&gt;    
            &lt;last-name&gt;Blough&lt;/last-name&gt;    
        &lt;/user&gt;    
    &lt;/users&gt;    
&lt;/x:parse&gt;    
    
&lt;c:set var="userId" value="${{user.id}}" scope="page"/&gt;    
    
&lt;x:set var="user" source="${{doc}}" select="//users/user[@id=$pageScope:userId]"/&gt;    
    
Hi &lt;x:out source="${{user}}" select="/first-name"/&gt; !
   </value>
  </data>
  <data name="description_Sharp_Scope" xml:space="preserve">
    <value>Pushes a new tag scope on the stack. So tag level variables can be used without changes the early created variables.</value>
  </data>
  <data name="description_ExpressionLanguage_Note" xml:space="preserve">
    <value>In java dictionary and list access is done with brackets. SharpTiles deviates from this syntax. In SharpTiles access to properties, 
   list, dictionaries is done with the same '.' notation.    
       
   For example:    
       
    *map["key"][i].property* becomes *map.key.i.property*        
	The underlying implementation of the properties is now hidden from the view logic.
   </value>
  </data>
  <data name="expression_Header_Operator" xml:space="preserve">
    <value>Operator</value>
  </data>
  <data name="expression_Header_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="description_MathParser" xml:space="preserve">
    <value>Math</value>
  </data>
 <data name="description_AddParser" xml:space="preserve">
    <value>Addition</value>
  </data>
  <data name="description_MinusParser" xml:space="preserve">
    <value>Subtraction</value>
  </data>
  <data name="description_MultiplyParser" xml:space="preserve">
    <value>Multliplication</value>
  </data>
  <data name="description_DivideParser" xml:space="preserve">
    <value>Division</value>
  </data>
  <data name="description_ModuloParser" xml:space="preserve">
    <value>Remainder(modulo)</value>
  </data>
  <data name="description_PowerParser" xml:space="preserve">
    <value>Power</value>
  </data>
  <data name="description_StringConstantParser" xml:space="preserve">
    <value>String constant</value>
  </data>
  <data name="description_ConstantParser" xml:space="preserve">
    <value>Constant (will be interpreted as bool or decimal if possible)</value>
  </data>
  <data name="description_BracketsParser" xml:space="preserve">
    <value>Paranthesis for changing operator precedence or used as parameters in function calls</value>
  </data>
  <data name="description_NotParser" xml:space="preserve">
    <value>not</value>
  </data>
  <data name="description_LessThanParser" xml:space="preserve">
    <value>Less than</value>
  </data>
  <data name="description_GreaterThanParser" xml:space="preserve">
    <value>Greater than</value>
  </data>
  <data name="description_LessThanOrEqualParser" xml:space="preserve">
    <value>Less than or equal to</value>
  </data>
  <data name="description_GreaterThanOrEqualParser" xml:space="preserve">
    <value>Greater than or equal to</value>
  </data>
  <data name="description_EqualToParser" xml:space="preserve">
    <value>Equal to</value>
  </data>
  <data name="description_NotEqualToParser" xml:space="preserve">
    <value>Not equal to</value>
  </data>
  <data name="description_AndParser" xml:space="preserve">
    <value>Logic and right parameter lazy evaluated</value>
  </data>
  <data name="description_OrParser" xml:space="preserve">
    <value>Logic or right parameter lazy evaluated</value>
  </data>
  <data name="description_FunctionParser" xml:space="preserve">
    <value>Function call</value>
  </data>
  <data name="type_String" xml:space="preserve">
    <value>string</value>
  </data>
  <data name="type_DateTime" xml:space="preserve">
    <value>date time</value>
  </data>
  <data name="type_Int32" xml:space="preserve">
    <value>integer</value>
  </data>
  <data name="type_Boolean" xml:space="preserve">
    <value>boolean</value>
  </data>
  <data name="type_Object" xml:space="preserve">
    <value>object</value>
  </data>
  <data name="type_String[]" xml:space="preserve">
    <value>string[]</value>
  </data>
  <data name="type_IEnumerable" xml:space="preserve">
    <value>IEnumerable</value>
  </data>
  <data name="function_Header_Operator" xml:space="preserve">
    <value>Function</value>
  </data>
  <data name="function_Header_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="description_LengthFunction" xml:space="preserve">
    <value>If a collection or array is passed, the size of the collection or array is
returned; If a string is passed, the number of characters in the string is
returned.</value>
  </data>
  <data name="description_ReverseFunction" xml:space="preserve">
    <value>If a collection, string or array is passed. The order of the elements will be reversed.</value>
  </data>
  <data name="description_ConcatFunction" xml:space="preserve">
    <value>Concatenates the left string with the right string.</value>
  </data>
  <data name="description_EmptyFunction" xml:space="preserve">
    <value>True if the operand is null, an empty String, empty array, empty Map, or empty List; false, otherwise.</value>
  </data>
  <data name="description_ContainsFunction" xml:space="preserve">
    <value>Returns true if substring is contained in source; false, otherwise.</value>
  </data>
  <data name="description_ContainsIgnoreCaseFunction" xml:space="preserve">
    <value>Returns true if substring is contained in source regardless of case; false,
otherwise.</value>
  </data>
  <data name="description_IndexOfFunction" xml:space="preserve">
    <value>Returns an integer representing the 0-based index within source of the first
occurrence of substring. If substring is empty, 0 is returned.</value>
  </data>
  <data name="description_StartsWithFunction" xml:space="preserve">
    <value>Returns true if source starts with the specified prefix; false, otherwise.</value>
  </data>
  <data name="description_EndsWithFunction" xml:space="preserve">
    <value>Returns true if source ends with the specified suffix; false, otherwise.</value>
  </data>
  <data name="description_ReplaceFunction" xml:space="preserve">
    <value>Replaces in source, every occurrence of oldValue with
the newValue. An empty string is returned if either inputString or
oldValue is empty. If newVlaue is empty, all occurences of the
oldValue are removed.</value>
  </data>
  <data name="description_JoinFunction" xml:space="preserve">
    <value>Joins all elements of the parts into a single string. Separator
separates each element in the resulting string. If separator is an empty string, the elements are joined without a separator.</value>
  </data>
  <data name="description_SplitFunction" xml:space="preserve">
    <value>Splits string into a string array using the given set of delimiter characters.
The delimiter characters are not included in any returned tokens.</value>
  </data>
  <data name="description_EscapeXmlFunction" xml:space="preserve">
    <value>Escapes characters (e.g changing "&lt;" to "&amp; lt;") that could be interpreted as XML (including HTML) markup.</value>
  </data>
  <data name="description_ToLowerCaseFunction" xml:space="preserve">
    <value>Converts all characters of a string to lowercase.</value>
  </data>
  <data name="description_ToUpperCaseFunction" xml:space="preserve">
    <value>Converts all characters of a string to uppercase.</value>
  </data>
  <data name="description_TrimFunction" xml:space="preserve">
    <value>Removes whitespace from both ends of a string.</value>
  </data>
  <data name="description_SubStringFunction" xml:space="preserve">
    <value>Returns a subset of source using the zero-based indices. inclusive of the
begin index, but exclusive of the end index.</value>
  </data>
  <data name="description_SubStringBeforeFunction" xml:space="preserve">
    <value>Returns the subset of source that procedes the given substring.</value>
  </data>
  <data name="description_SubStringAfterFunction" xml:space="preserve">
    <value>Returns the subset of source that succedes the given substring.</value>
  </data>
  <data name="expression_ArithmeticExpression" xml:space="preserve">
    <value>Arithmetic expressions</value>
  </data>
  <data name="expression_OtherExpression" xml:space="preserve">
    <value>Other</value>
  </data>
  <data name="expression_Comparison" xml:space="preserve">
    <value>Comparison expressions</value>
  </data>
  <data name="expression_LogicExpression" xml:space="preserve">
    <value>Boolean logic expressions</value>
  </data>
  <data name="title_Operators" xml:space="preserve">
    <value>Operators</value>
  </data>
  <data name="title_OperatorPrecedence" xml:space="preserve">
    <value>Operator precedence</value>
  </data>
  <data name="expression_Header_Priority" xml:space="preserve">
    <value>Priority</value>
  </data>
  <data name="tag_Header_Default" xml:space="preserve">
    <value>Default</value>
  </data>
  <data name="description_Tiles_Title" xml:space="preserve">
    <value>Tiles *Tag Library*</value>
  </data>
  <data name="description_Tiles" xml:space="preserve">
    <value>The tiles tag lib provides functionality to include defined tiles in to the page.</value>
  </data>
  <data name="description_Tiles_Insert" xml:space="preserve">
    <value>Inserts a configured tile into the page. The available tiles set is configured in a seperate config file.</value>
  </data>
  <data name="description_Tiles_Insert_Note" xml:space="preserve">
    <value>
		Unlike Java Tiles, the inserted tile uses the same model as the parent tile/page so all variables can be used directly. 
		The sharing of the same page model also makes the *&lt;tiles:importAttribute/&gt;* obsolete
	</value>
  </data>
  <data name="description_Tiles_Insert_Example" xml:space="preserve">
    <value>
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;   
    &lt;head&gt;   
        &lt;title&gt;Sample&lt;/title&gt;   
    &lt;/head&gt;   
    &lt;body&gt;   
        &lt;div id="menu"&gt;   
            &lt;tiles:insert name='menu'/&gt;   
        &lt;/div&gt;   
        &lt;hr /&gt;   
        &lt;div id="main"&gt;   
            &lt;tiles:insert name='body'/&gt;   
        &lt;/div&gt;   
    &lt;/body&gt;   
&lt;/html&gt;   
    </value>
  </data>
  <data name="description_Tiles_Insert_Name" xml:space="preserve">
    <value>The name of the tile to import</value>
  </data>

  <data name="description_Html" xml:space="preserve">
    <value>The html tag lib provides a wrapper to access the [HtmlHelper](http://www.codeplex.com/MVCContrib/Wiki/View.aspx?title=FormHelper&amp;referringTitle=Documentation).</value>
  </data>
  <data name="description_Html_Note" xml:space="preserve">
    <value>The html tag lib is only available in combination with ASP.NET MVC.   This is because the html tag lib is implemented with the HtmlHelper, which is only available in ASP.NET MVC.
   </value>
  </data>
  <data name="description_Html_ActionTag" xml:space="preserve"><value>Renders an action url.</value></data>
  
  <data name="description_Html_Action" xml:space="preserve">
    <value>Wraps te UrlHelper and HtmlHelper to make refering to controllers more easy</value>
  </data>

  <data name="description_Html_HtmlInput" xml:space="preserve">
    <value>Wraps te Input extensions</value>
  </data>

  <data name="description_Html_ActionTag_Example" xml:space="preserve">
    <value>&lt;html:action action='${{Model.action}}' controller='LoginController'/&gt;</value>
  </data>
  
  <data name="description_Html_ActionTag_Action" xml:space="preserve">
    <value>Action to be called on the controller</value>
  </data>
  
  <data name="description_Html_ActionTag_Controller" xml:space="preserve">
    <value>Controller to redirect to</value>
  </data>
  
  <data name="description_Html_FormTag" xml:space="preserve">
    <value>Simulates the form extensions method. A new implementation was required, because the existing form extensions writes directly to the http response.</value>
  </data>
  
  <data name="description_Html_FormTag_Example" xml:space="preserve">
    <value>&lt;html:form action='${{Model.action}}' controller='${{Model.controller}}' method='post'&gt;    
    &lt;html:textBox name='${{Model.textBoxName}}' value='${{Model.textBoxValue}}' class='${{Model.style}}'/&gt;    
&lt;/html:form&gt;
</value>
  </data>
  
  <data name="description_Html_FormTag_Action" xml:space="preserve">
    <value>Name of the action used to handle the post</value>
  </data>

  <data name="description_Html_Actie" xml:space="preserve">
    <value>
    This taglib basicly is a wrapper for all extension methods on the HtmlHelper. This allows you add a tag like 
     &lt;p&gt;
        &lt;code&gt;
        &lt;html:checkBox name=&quot;rememberMe&quot; isChecked=&quot;${{Model.checkBoxValue}}&quot; class=&quot;loginform&quot;/&gt; &lt;/br&gt;
        &lt;/code&gt;
    &lt;/p&gt;
    to your page. The example wraps the following method: &lt;/br&gt;
    &lt;p&gt;
        &lt;code&gt;
                   InputExtensions.CheckBox(
                    
                        HtmlHelper htmlHelper,
                    
                        string name,
                    
                        boolean isChecked,
                    
                        IDictionary&lt;string, object&gt; htmlAttributes
                    ) : string
                 &lt;/code&gt;
    &lt;/p&gt;    
    In a aspx page the example would look like this:&lt;p&gt;
        &lt;code&gt;
			&lt;%=HtmlHelper.CheckBox(&quot;rememberMe&quot;, ViewData.Model.CheckBoxvalue, new {{class=&quot;formInput&quot;}});%&gt;
	    &lt;/code&gt;
    &lt;/p&gt;&lt;/br&gt;
	SharpTiles will always look for a matching method with the least amount of parameters. The parameter names are matched on name with two exceptions, htmlHelper and  htmlAttributes
	the  htmlHelper is added automaticly by the framework. The  htmlAttributes is a dictionary containing key value pairs of unmatched attributes. So our example requires a
	method with name checkBox and a parameter name and a parameter isChecked. Further more there isn't a method which takes class as a parameter so this is stored in the htmlAttributes. This 
	makes that the method we are looking for also required a parameters htmlAttributes. SharpTiles will search for this method and makes the call.
	All parameters are evaluated by shaprtiles before being passed through the html helper.&lt;br/&gt;
	Below this introduction all wrapped methods are enumerated. A different version of your HtmlHelper might change the availability of the wrapped methods.
    </value>
  </data>

  <data name="description_Html_FormTag_Controller" xml:space="preserve">
    <value>Name of the controller to post to. If omitted the current controller is used</value>
  </data>
  
  <data name="description_Html_FormTag_Method" xml:space="preserve">
    <value>Set how this form is posted.</value>
  </data>
  
  <data name="description_Html_FormTag_Id" xml:space="preserve">
    <value>The id of the form</value>
  </data>

  <data name="description_HtmlHelperWrapperTag_Id" xml:space="preserve">
    <value>The id of the tag</value>
  </data>
  <data name="description_Html_Title" xml:space="preserve"><value>Html wrapper *Tag Library*</value></data>
  <data name="description_Html_CheckBoxTag" xml:space="preserve"><value>Wraps the check box helper method</value></data>
  <data name="description_Html_HtmlInput" xml:space="preserve"><value>All the html helper methods</value></data>
  <data name="description_Html_CheckBoxTag_Example" xml:space="preserve"><value>&lt;html:checkBox name='${{Model.checkBoxName}}' isChecked='${{Model.checkBoxValue}}' class='${{Model.style}}'/&gt;</value></data>
  <data name="description_Html_HiddenTag" xml:space="preserve"><value>Wraps the hidden helper method</value></data>
  <data name="description_Html_HiddenTag_Example" xml:space="preserve"><value>&lt;html:hidden name='${{Model.hiddenName}}' value='${{Model.hiddenValue}}' class='${{Model.style}}'/&gt;</value></data>
  <data name="description_Html_PasswordTag" xml:space="preserve"><value>Wraps the password helper method</value></data>
  <data name="description_Html_PasswordTag_Example" xml:space="preserve"><value>&lt;html:password name="${{Model.passwordName}}" value="${{Model.passwordValue}}" class="${{Model.style}}"/&gt;</value></data>
  <data name="description_Html_RadioButtonTag" xml:space="preserve"><value>Wraps the radion button helper method</value></data>
  <data name="description_Html_RadioButtonTag_Example" xml:space="preserve"><value>&lt;html:radioButton name="${{Model.radioButtonName}}" value="${{Model.radioButtonValue}}" class="${{Model.style}}"/&gt;</value></data>
  <data name="description_Html_TextBoxTag" xml:space="preserve"><value>Wraps the text box helper method</value></data>
  <data name="description_Html_TextBoxTag_Example" xml:space="preserve"><value>&lt;html:textBox name='${{Model.textBoxName}}' value='${{Model.textBoxValue}}' class='${{Model.style}}"/></value></data>
  <data name="description_Html_DropDownListTag" xml:space="preserve"><value>Wraps the drop down list helper method</value></data>
  <data name="description_Html_DropDownListTag_Example" xml:space="preserve"><value>&lt;html:dropDownList name='${{Model.dropDownListName}}' selectList='${{Model.selectList}}"/&gt;</value></data>
  <data name="description_Html_ListBoxTag" xml:space="preserve"><value>Wraps the list box helper method</value></data>
  <data name="description_Html_ListBoxTag_Example" xml:space="preserve"><value>&lt;html:listBox name='${{Model.listBoxName}}' selectList='${{Model.mutliList}}'/&gt;</value></data>
  <data name="description_Html_TextAreaTag" xml:space="preserve"><value>Wraps the textarea box helper method</value></data>
  <data name="description_Html_TextAreaTag_Example" xml:space="preserve"><value>&lt;html:textArea name='${{Model.textAreaName}}' value='${{Model.textAreaValue}}' columns='${{Model.columns}}' rows='${{Model.rows}}' class='htmlEditor'/&gt;</value></data>
  <data name="description_Html_ValidationMessageTag" xml:space="preserve"><value>Wraps the validation message helper</value></data>
  <data name="description_Html_ValidationMessageTag_Example" xml:space="preserve"><value>&lt;html:validationMessage modelName='${{Model.modelName}}' validationMessage='${{Model.validationMessage}}'/&gt;</value></data>
  <data name="description_Html_ValidationSummaryTag" xml:space="preserve"><value>The name of the tile to import</value></data>
  <data name="description_Html_ValidationSummaryTag_Example" xml:space="preserve"><value>&lt;html:validationSummary message='msg' class='errorReport'/&gt;</value></data>
  <data name="type_IDictionary`2" xml:space="preserve"><value>IDictionary&lt;string, object&gt;</value></data>
  <data name="type_IEnumerable`1" xml:space="preserve"><value>IEnumerable&lt;SelectListItem&gt;</value></data>
  <data name="type_HtmlHelper" xml:space="preserve"><value>*HtmlHelper*</value></data>
  <data name="description_Tiles_InsertTemplate" xml:space="preserve">
    <value>Allows pages to enter a masterpage without explictely defining it in the tiles.xml configuration file.
*Contributed by Ronald Dehuysser*</value>
  </data>
  <data name="description_Tiles_InsertTemplate_Example" xml:space="preserve">
    <value>&lt;tiles:insertTemplate template="/Views/Shared/Masterpage.tile"&gt;   
    &lt;tiles:putAttribute name="title" value="Sample Title"/&gt;   
    &lt;tiles:putAttribute name="Top Navigation" value="/Views/Shared/navigation.tile"/&gt;   
    &lt;tiles:putAttribute name="body"&gt;   
    &lt;div id="main"&gt;   
        &lt;p&gt;Dit is de body&lt;/p&gt;   
    &lt;/div&gt;   
&lt;/tiles:insertTemplate&gt;   </value>
  </data>
  <data name="description_Tiles_InsertTemplate_Template" xml:space="preserve">
    <value>Defines the template that will be used to display the current page.</value>
  </data>
  <data name="description_Tiles_PutAttribute" xml:space="preserve">
    <value>This tag allows attibutes to be add to the current page.
*Contributed by Ronald Dehuysser*</value>
  </data>
  <data name="description_Tiles_PutAttribute_Example" xml:space="preserve">
    <value>See the example for the &lt;tiles:insertTemplate /&gt; tag.</value>
  </data>
  <data name="description_Tiles_PutAttribute_Name" xml:space="preserve">
    <value>This attribute defines the name of the current tile attribute and must match one of the Tiles insert names in the masterpage so it can be imported.</value>
  </data>
  <data name="description_Tiles_PutAttribute_Value" xml:space="preserve">
    <value>The value of the attribute to be imported. This value is not required and can be provided in the body of the tag. If provided, it can be a plain string value or a url. If the value starts with a '/' it is used as a url and the file provided by the url is imported.</value>
  </data>
  <data name="description_Tiles_PutAttribute_TileType" xml:space="preserve">
    <value>Like tiles defined in the tiles.xml The tile factory will guess the tile type (template or string). You can override the guessing by defining the type</value>
  </data>
  <data name="description_Tiles_Insert_Mandatory" xml:space="preserve">
    <value>If this attribute is set to false and the attribute specified by the name does not exist then nothing will be rendered. The default value, true, will raise an error.</value>
  </data>

</root>